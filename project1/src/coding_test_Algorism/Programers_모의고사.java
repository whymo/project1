package coding_test_Algorism;

import java.util.Arrays;

public class Programers_모의고사 {
	
	public int[] solution(int[] answers) {
        
        // ============================================================================
        // 수포자 3명이 각각 다음과 같은 방법으로 문제를 찍을 때,
        // 정답이 든 answer 배열이 주어질 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 반환하라
        
        // 수포자 1 :  1 -> 2 -> 3 -> 4 -> 5 -> 1 ..
        // 수포자 2 :  ( 2, 1 ) -> ( 2, 3 ) -> ( 2, 4 ) -> ( 2, 5 ) -> ( 2, 1 ) ...
        // 수포자 3 :  ( 3, 3 ) ->  ( 1, 1 ) -> ( 2, 2 ) -> ( 4, 4 ) -> ( 5, 5 ) -> ( 3, 3 ) ...
        
        // 시험은 최대 10,000 문제로 구성되어있다
        // 문제의 정답은 1, 2, 3, 4, 5중 하나이다.
        // 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해야 한다.
        // ============================================================================
        
        // 정답 배열은 answers이다.
        // 최고 점수 수포자 반환 배열
        int [] answer;
        
        // ============================================================================
        
        // 수포자들이 찍는 방식을 각각의 배열에 넣는다.
        int [] a = { 1, 2, 3, 4, 5 }; // 수포자 1
        int [] b = { 2, 1, 2, 3, 2, 4, 2, 5}; // 수포자 2
        int [] c = { 3, 3, 1, 1, 2, 2, 4, 4, 5, 5}; // 수포자 3
        
        // 수포자들이 맞은 문제의 개수를 저장하는 배열 생성
        int [] score = { 0, 0, 0 };
        
        // ============================================================================
        
        // score 배열에 맞은 개수를 카운트해줌
        for( int i = 0; i < answers.length; i++ ){
            
            // 하나의 답을 가지고 각 수포자들이 맞은 개수를 카운트 해줘야 한다.
            
            // 수포자 1의 경우 5개씩 반복되기에 % 5로 해준다. ( %는 나머지 )
            if ( answers[i] == a [ i % 5 ] ) score[0]++;
            
            // 수포자 2의 경우에는 8개씩 반복되기에 % 8로 해준다.
            if ( answers[i] == b [ i % 8 ] ) score[1]++;
            
            // 수포자 3의 경우에는 10개씩 반복되기에 % 10로 해준다.
            if ( answers[i] == c [ i % 10 ] ) score[2]++;
            
        } // for
        
        // ============================================================================
        
        // 가장 많이 맞힌 수포자의 문제 개수
        // 가장 높은 점수를 알기 위해서 먼저 max라는 변수에 0을 임시로 넣은 후
        // score 배열을 순회하면서 더 높은 점수를 max에 저장
        int max = 0;
        for ( int i = 0; i < score.length; i++ ){
            
            if( score[i] > max ) {
                max = score[i];
            }; // if : 더 높은 점수를 max라는 변수에 넣음
            
        } // for
        
        // ============================================================================
        
        // 가장 높은 점수를 받은 사람의 수
        // 가장 높은 점수를 받은 사람이 1명 이상이면, 오름차순으로 정렬해서 보여줘야 한다.
        // 1, 2, 3 모두 2개를 맞추었다면 [ 1, 2, 3 ]으로 반환해야 한다.
        int maxP = 0;
        for ( int i = 0; i < score.length; i++ ){
        
            if (score[i] == max ){
                maxP ++;
            } // if : 최고 점수와 같다면 +1씩 해준다.
            
        } // for : 가장 높은 점수를 받은 수포자의 수 카운팅
        
        // ============================================================================
        
        // answer 배열은 가장 높은 점수를 받은 사람만 반환되기에
        // answer 배열은 maxP의 사이즈와 같으면 된다.
        answer = new int [maxP];
        
        // answer 배열의 원소 순번은 따로 카운트 해줘야 한다.
        int idx = 0;
        
        for ( int i = 0; i < score.length; i++ ) {
            
            if ( score[i] == max ) {
                // i + 1을 해줘야 하는 이유는 수포자는 1부터 시작하지만 배열은 0부터 시작하기 때문이다.
                answer[idx] = i + 1;
                idx ++;
            } // if : 최고 득점자라면 배열에 추가
                
        } // for
            
        return answer;
        
    } // solution
	
	public static void main(String[] args) {
		
		int [] answers = { 1, 2, 3, 4, 5 };
		
		Programers_모의고사 test = new Programers_모의고사();
		
		System.out.println(Arrays.toString(test.solution(answers)));
		
	} // main

} //end class
